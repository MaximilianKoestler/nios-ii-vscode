{
  "add": {
    "type": "instruction",
    "assemblerSyntax": "add rC, rA, rB",
    "description": "Calculates the sum of rA and rB. Stores the result in rC. Used for both signed and unsigned addition.",
    "example": "add r6, r7, r8",
    "exceptions": "None",
    "instruction": "add immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "add",
    "operation": "rC \u2190 rA + rB",
    "usage": "Carry Detection (unsigned operands):\nFollowing an add operation, a carry out of the MSB can be detected by checking whether the unsigned sum is less than one of the unsigned operands. The carry bit can be written to a register, or a conditional branch can be taken based on the carry condition. The following code shows both cases:\n```niosii\nadd rC, rA, rB\ncmpltu rD, rC, rA\nadd rC, rA, rB\nbltu rC, rA, label\n// The original add operation\n// rD is written with the carry bit\n// The original add operation\n// Branch if carry generated\n```\n Overflow Detection (signed operands):\nAn overflow is detected when two positives are added and the sum is negative, or when two negatives are added and the sum is positive. The overflow condition can control a conditional branch, as shown in the following code:\n```niosii\nadd rC, rA, rB\nxor rD, rC, rA\nxor rE, rC, rB\nand rD, rD, rE\nblt rD, r0,label\n// The original add operation\n// Compare signs of sum and rA\n// Compare signs of sum and rB\n// Combine comparisons\n// Branch if overflow occurred\n```\n"
  },
  "addi": {
    "type": "instruction",
    "assemblerSyntax": "addi rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value and adds it to the value of rA. Stores the sum in rB.",
    "example": "addi r6, r7, -100",
    "exceptions": "None",
    "instruction": "addi",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "addi",
    "operation": "rB \u2190 rA + \u03c3(IMM16)",
    "usage": "Carry Detection (unsigned operands):\nFollowing an addi operation, a carry out of the MSB can be detected by checking whether the unsigned sum is less than one of the unsigned operands. The carry bit can be written to a register, or a conditional branch can be taken based on the carry condition. The following code shows both cases:\n```niosii\naddi rB, rA, IMM16\ncmpltu rD, rB, rA\naddi rB, rA, IMM16\nbltu rB, rA, label\n// The original add operation\n// rD is written with the carry bit\n// The original add operation\n// Branch if carry generated\n```\n Overflow Detection (signed operands):\nAn overflow is detected when two positives are added and the sum is negative, or when two negatives are added and the sum is positive. The overflow condition can control a conditional branch, as shown in the following code:\n```niosii\naddi rB, rA, IMM16\nxor rC, rB, rA\nxorhi rD, rB, IMM16\nand rC, rC, rD\nblt rC, r0,label\n// The original add operation\n// Compare signs of sum and rA\n// Compare signs of sum and IMM\n// Combine comparisons\n// Branch if overflow occurred\n```\n"
  },
  "and": {
    "type": "instruction",
    "assemblerSyntax": "and rC, rA, rB",
    "description": "Calculates the bitwise logical AND of rA and rB and stores the result in rC.",
    "example": "and r6, r7, r8",
    "exceptions": "None",
    "instruction": "bitwise logical and",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "and",
    "operation": "rC \u2190 rA & rB"
  },
  "andhi": {
    "type": "instruction",
    "assemblerSyntax": "andhi rB, rA, IMM16",
    "description": "Calculates the bitwise logical AND of rA and (IMM16 : 0x0000) and stores the result in rB.",
    "example": "andhi r6, r7, 100",
    "exceptions": "None",
    "instruction": "bitwise logical and immediate into high halfword",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "andhi",
    "operation": "rB \u2190 rA & (IMM16 : 0x0000)"
  },
  "andi": {
    "type": "instruction",
    "assemblerSyntax": "andi rB, rA, IMM16",
    "description": "Calculates the bitwise logical AND of rA and (0x0000 : IMM16) and stores the result in rB.",
    "example": "andi r6, r7, 100",
    "exceptions": "None",
    "instruction": "bitwise logical and immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "andi",
    "operation": "rB \u2190 rA & (0x0000 : IMM16)"
  },
  "beq": {
    "type": "instruction",
    "assemblerSyntax": "beq rA, rB, label",
    "description": "If rA == rB, then beq transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following beq. The two least-signifi\u2010 cant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "beq r6, r7, label",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if equal",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "beq",
    "operation": "if (rA == rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "bge": {
    "type": "instruction",
    "assemblerSyntax": "bge rA, rB, label",
    "description": "If (signed) rA >= (signed) rB, then bge transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following bge. The two least-significant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "bge r6, r7, top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if greater than or equal signed",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "bge",
    "operation": "if ((signed) rA >= (signed) rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "bgeu": {
    "type": "instruction",
    "assemblerSyntax": "bgeu rA, rB, label",
    "description": "If (unsigned) rA >= (unsigned) rB, then bgeu transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following bgeu. The two least-significant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "bgeu r6, r7, top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if greater than or equal unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "bgeu",
    "operation": "if ((unsigned) rA >= (unsigned) rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "bgt": {
    "type": "instruction",
    "assemblerSyntax": "bgt rA, rB, label",
    "description": "If (signed) rA > (signed) rB, then bgt transfers program control to the instruction at label. Pseudo-instruction bgt is implemented with the blt instruction by swapping the register operands.",
    "example": "bgt r6, r7, top_of_loop",
    "instruction": "branch if greater than signed",
    "mnemonic": "bgt",
    "operation": "if ((signed) rA > (signed) rB) then PC \u2190 label else PC \u2190 PC + 4"
  },
  "bgtu": {
    "type": "instruction",
    "assemblerSyntax": "bgtu rA, rB, label",
    "description": "If (unsigned) rA > (unsigned) rB, then bgtu transfers program control to the instruction at label. Pseudo-instruction bgtu is implemented with the bltu instruction by swapping the register operands.",
    "example": "bgtu r6, r7, top_of_loop",
    "instruction": "branch if greater than unsigned",
    "mnemonic": "bgtu",
    "operation": "if ((unsigned) rA > (unsigned) rB) then PC \u2190 label else PC \u2190 PC + 4"
  },
  "ble": {
    "type": "instruction",
    "assemblerSyntax": "ble rA, rB, label",
    "description": "If (signed) rA <= (signed) rB, then ble transfers program control to the instruction at label. Pseudo-instruction ble is implemented with the bge instruction by swapping the register operands.",
    "example": "ble r6, r7, top_of_loop",
    "instruction": "branch if less than or equal signed",
    "mnemonic": "ble",
    "operation": "if ((signed) rA <= (signed) rB) then PC \u2190 label else PC \u2190 PC + 4"
  },
  "bleu": {
    "type": "instruction",
    "assemblerSyntax": "bleu rA, rB, label",
    "description": "If (unsigned) rA <= (unsigned) rB, then bleu transfers program counter to the instruction at label. Pseudo-instruction bleu is implemented with the bgeu instruction by swapping the register operands.",
    "example": "bleu r6, r7, top_of_loop",
    "instruction": "branch if less than or equal to unsigned",
    "mnemonic": "bleu",
    "operation": "if ((unsigned) rA <= (unsigned) rB) then PC \u2190 label else PC \u2190 PC + 4"
  },
  "blt": {
    "type": "instruction",
    "assemblerSyntax": "blt rA, rB, label",
    "description": "If (signed) rA < (signed) rB, then blt transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following blt. The two least-significant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "blt r6, r7, top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if less than signed",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "blt",
    "operation": "if ((signed) rA < (signed) rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "bltu": {
    "type": "instruction",
    "assemblerSyntax": "bltu rA, rB, label",
    "description": "If (unsigned) rA < (unsigned) rB, then bltu transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following bltu. The two least-significant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "bltu r6, r7, top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if less than unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "bltu",
    "operation": "if ((unsigned) rA < (unsigned) rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "bne": {
    "type": "instruction",
    "assemblerSyntax": "bne rA, rB, label",
    "description": "If rA != rB, then bne transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following bne. The two least-signifi\u2010 cant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "bne r6, r7, top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "branch if not equal",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "bne",
    "operation": "if (rA != rB) then PC \u2190 PC + 4 + \u03c3(IMM16) else PC \u2190 PC + 4"
  },
  "br": {
    "type": "instruction",
    "assemblerSyntax": "br label",
    "description": "Transfers program control to the instruction at label. In the instruction encoding, the offset given by IMM16 is treated as a signed number of bytes relative to the instruction immediately following br. The two least-significant bits of IMM16 are always zero, because instruction addresses must be word-aligned.",
    "example": "br top_of_loop",
    "exceptions": "Misaligned destination address",
    "instruction": "unconditional branch",
    "instructionFields": "IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "br",
    "operation": "PC \u2190 PC + 4 + \u03c3(IMM16)"
  },
  "break": {
    "type": "instruction",
    "assemblerSyntax": "break\nbreak imm",
    "description": "Breaks program execution and transfers control to the debugger break-processing routine. Saves the address of the next instruction in register ba and saves the contents of the status register in bstatus. Disables interrupts, then transfers execution to the break handler. The 5-bit immediate field imm5 is ignored by the processor, but it can be used by the debugger. break with no argument is the same as break 0.",
    "example": "break",
    "exceptions": "Break",
    "instruction": "debugging breakpoint",
    "instructionFields": "IMM5 = Type of breakpoint",
    "instructionType": "R",
    "mnemonic": "break",
    "operation": "bstatus \u2190 status PIE \u2190 0 U \u2190 0 ba \u2190 PC + 4 PC \u2190 break handler address",
    "usage": "break is used by debuggers exclusively. Only debuggers should place break in a user program, operating system, or exception handler. The address of the break handler is specified with the Nios_II Processor parameter editor in Qsys. Some debuggers support break and break 0 instructions in source code. These debuggers treat the break instruction as a normal breakpoint."
  },
  "bret": {
    "type": "instruction",
    "assemblerSyntax": "bret",
    "description": "Copies the value of bstatus to the status register, then transfers execution to the address in ba.",
    "example": "bret",
    "exceptions": "Misaligned destination address Supervisor-only instruction",
    "instruction": "breakpoint return",
    "instructionFields": "None",
    "instructionType": "R",
    "mnemonic": "bret",
    "operation": "status \u2190 bstatus PC \u2190 ba",
    "usage": "bret is used by debuggers exclusively and should not appear in user programs, operating systems, or exception handlers."
  },
  "call": {
    "type": "instruction",
    "assemblerSyntax": "call label",
    "description": "Saves the address of the next instruction in register ra, and transfers execution to the instruction at address (PC31..28 : IMM26 x 4).",
    "example": "call write_char",
    "exceptions": "None",
    "instruction": "call subroutine",
    "instructionFields": "IMM26 = 26-bit unsigned immediate value",
    "instructionType": "J",
    "mnemonic": "call",
    "operation": "ra \u2190 PC + 4 PC \u2190 (PC31..28 : IMM26 x 4)",
    "usage": "call can transfer execution anywhere within the 256-MB range determined by PC31..28. The Nios II GNU linker does not automatically handle cases in which the address is out of this range."
  },
  "callr": {
    "type": "instruction",
    "assemblerSyntax": "callr rA",
    "description": "Saves the address of the next instruction in the return address register, and transfers execution to the address contained in register rA.",
    "example": "callr r6",
    "exceptions": "Misaligned destination address",
    "instruction": "call subroutine in register",
    "instructionFields": "A = Register index of operand rA",
    "instructionType": "R",
    "mnemonic": "callr",
    "operation": "ra \u2190 PC + 4 PC \u2190 rA",
    "usage": "callr is used to dereference C-language function pointers."
  },
  "cmpeq": {
    "type": "instruction",
    "assemblerSyntax": "cmpeq rC, rA, rB",
    "description": "If rA == rB, then stores 1 to rC; otherwise, stores 0 to rC.",
    "example": "cmpeq r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare equal",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "cmpeq",
    "operation": "if (rA == rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpeq performs the == operation of the C program\u2010 ming language. Also, cmpeq can be used to implement the C logical negation operator \u201c!\u201d.\n```niosii\ncmpeq rC, rA, r0\n// Implements rC = !rA\n```\n"
  },
  "cmpeqi": {
    "type": "instruction",
    "assemblerSyntax": "cmpeqi rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA == \u03c3(IMM16), cmpeqi stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpeqi r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare equal immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "cmpeqi",
    "operation": "if (rA \u03c3(IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpeqi performs the == operation of the C programming language."
  },
  "cmpge": {
    "type": "instruction",
    "assemblerSyntax": "cmpge rC, rA, rB",
    "description": "If rA >= rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpge r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare greater than or equal signed",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "I",
    "mnemonic": "cmpge",
    "operation": "if ((signed) rA >= (signed) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpge performs the signed >= operation of the C programming language."
  },
  "cmpgei": {
    "type": "instruction",
    "assemblerSyntax": "cmpgei rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA >= \u03c3(IMM16), then cmpgei stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpgei r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare greater than or equal signed immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "R",
    "mnemonic": "cmpgei",
    "operation": "if ((signed) rA >= (signed) \u03c3(IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpgei performs the signed >= operation of the C programming language."
  },
  "cmpgeu": {
    "type": "instruction",
    "assemblerSyntax": "cmpgeu rC, rA, rB",
    "description": "If rA >= rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpgeu r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare greater than or equal unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "cmpgeu",
    "operation": "if ((unsigned) rA >= (unsigned) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpgeu performs the unsigned >= operation of the C programming language."
  },
  "cmpgeui": {
    "type": "instruction",
    "assemblerSyntax": "cmpgeui rB, rA, IMM16",
    "description": "Zero-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA >= (0x0000 : IMM16), then cmpgeui stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpgeui r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare greater than or equal unsigned immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "cmpgeui",
    "operation": "if ((unsigned) rA >= (unsigned) (0x0000 : IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpgeui performs the unsigned >= operation of the C programming language."
  },
  "cmpgt": {
    "type": "instruction",
    "assemblerSyntax": "cmpgt rC, rA, rB",
    "description": "If rA > rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpgt r6, r7, r8",
    "instruction": "compare greater than signed",
    "mnemonic": "cmpgt",
    "operation": "if ((signed) rA > (signed) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpgt performs the signed > operation of the C programming language. Pseudo-instruction cmpgt is implemented with the cmplt instruction by swapping its rA and rB operands."
  },
  "cmpgti": {
    "type": "instruction",
    "assemblerSyntax": "cmpgti rB, rA, IMMED",
    "description": "Sign-extends the immediate value IMMED to 32 bits and compares it to the value of rA. If rA > \u03c3(IMMED), then cmpgti stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpgti r6, r7, 100",
    "instruction": "compare greater than signed immediate",
    "mnemonic": "cmpgti",
    "operation": "if ((signed) rA > (signed) IMMED) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpgti performs the signed > operation of the C programming language. The maximum allowed value of IMMED is 32766. The minimum allowed value is \u201332769. Pseudo-instruction cmpgti is implemented using a cmpgei instruction with an IMM16 immediate value of IMMED + 1."
  },
  "cmpgtu": {
    "type": "instruction",
    "assemblerSyntax": "cmpgtu rC, rA, rB",
    "description": "If rA > rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpgtu r6, r7, r8",
    "instruction": "compare greater than unsigned",
    "mnemonic": "cmpgtu",
    "operation": "if ((unsigned) rA > (unsigned) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpgtu performs the unsigned > operation of the C programming language. Pseudo-instruction cmpgtu is implemented with the cmpltu instruction by swapping its rA and rB operands."
  },
  "cmpgtui": {
    "type": "instruction",
    "assemblerSyntax": "cmpgtui rB, rA, IMMED",
    "description": "Zero-extends the immediate value IMMED to 32 bits and compares it to the value of rA. If rA > IMMED, then cmpgtui stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpgtui r6, r7, 100",
    "instruction": "compare greater than unsigned immediate",
    "mnemonic": "cmpgtui",
    "operation": "if ((unsigned) rA > (unsigned) IMMED) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpgtui performs the unsigned > operation of the C programming language. The maximum allowed value of IMMED is 65534. The minimum allowed value is 0. Pseudo-instruction cmpgtui is implemented using a cmpgeui instruc\u2010 tion with an IMM16 immediate value of IMMED + 1."
  },
  "cmple": {
    "type": "instruction",
    "assemblerSyntax": "cmple rC, rA, rB",
    "description": "If rA <= rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmple r6, r7, r8",
    "instruction": "compare less than or equal signed",
    "mnemonic": "cmple",
    "operation": "if ((signed) rA <= (signed) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmple performs the signed <= operation of the C programming language. Pseudo-instruction cmple is implemented with the cmpge instruction by swapping its rA and rB operands."
  },
  "cmplei": {
    "type": "instruction",
    "assemblerSyntax": "cmplei rB, rA, IMMED",
    "description": "Sign-extends the immediate value IMMED to 32 bits and compares it to the value of rA. If rA <= \u03c3(IMMED), then cmplei stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmplei r6, r7, 100",
    "instruction": "compare less than or equal signed immediate",
    "mnemonic": "cmplei",
    "operation": "if ((signed) rA < (signed) IMMED) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmplei performs the signed <= operation of the C programming language. The maximum allowed value of IMMED is 32766. The minimum allowed value is \u201332769. Pseudo-instruction cmplei is implemented using a cmplti instruction with an IMM16 immediate value of IMMED + 1."
  },
  "cmpleu": {
    "type": "instruction",
    "assemblerSyntax": "cmpleu rC, rA, rB",
    "description": "If rA <= rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpleu r6, r7, r8",
    "instruction": "compare less than or equal unsigned",
    "mnemonic": "cmpleu",
    "operation": "if ((unsigned) rA < (unsigned) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpleu performs the unsigned <= operation of the C programming language. Pseudo-instruction cmpleu is implemented with the cmpgeu instruction by swapping its rA and rB operands."
  },
  "cmpleui": {
    "type": "instruction",
    "assemblerSyntax": "cmpleui rB, rA, IMMED",
    "description": "Zero-extends the immediate value IMMED to 32 bits and compares it to the value of rA. If rA <= IMMED, then cmpleui stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpleui r6, r7, 100",
    "instruction": "compare less than or equal unsigned immediate",
    "mnemonic": "cmpleui",
    "operation": "if ((unsigned) rA <= (unsigned) IMMED) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpleui performs the unsigned <= operation of the C programming language. The maximum allowed value of IMMED is 65534. The minimum allowed value is 0. Pseudo-instruction cmpleui is implemented using a cmpltui instruc\u2010 tion with an IMM16 immediate value of IMMED + 1."
  },
  "cmplt": {
    "type": "instruction",
    "assemblerSyntax": "cmplt rC, rA, rB",
    "description": "If rA < rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmplt r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare less than signed",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "cmplt",
    "operation": "if ((signed) rA < (signed) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmplt performs the signed < operation of the C programming language."
  },
  "cmplti": {
    "type": "instruction",
    "assemblerSyntax": "cmplti rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA < \u03c3(IMM16), then cmplti stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmplti r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare less than signed immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "cmplti",
    "operation": "if ((signed) rA < (signed) \u03c3(IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmplti performs the signed < operation of the C programming language."
  },
  "cmpltu": {
    "type": "instruction",
    "assemblerSyntax": "cmpltu rC, rA, rB",
    "description": "If rA < rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpltu r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare less than unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "cmpltu",
    "operation": "if ((unsigned) rA < (unsigned) rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpltu performs the unsigned < operation of the C programming language."
  },
  "cmpltui": {
    "type": "instruction",
    "assemblerSyntax": "cmpltui rB, rA, IMM16",
    "description": "Zero-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA < (0x0000 : IMM16), then cmpltui stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpltui r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare less than unsigned immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "cmpltui",
    "operation": "if ((unsigned) rA < (unsigned) (0x0000 : IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpltui performs the unsigned < operation of the C programming language."
  },
  "cmpne": {
    "type": "instruction",
    "assemblerSyntax": "cmpne rC, rA, rB",
    "description": "If rA != rB, then stores 1 to rC; otherwise stores 0 to rC.",
    "example": "cmpne r6, r7, r8",
    "exceptions": "None",
    "instruction": "compare not equal",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "cmpne",
    "operation": "if (rA != rB) then rC \u2190 1 else rC \u2190 0",
    "usage": "cmpne performs the != operation of the C program\u2010 ming language."
  },
  "cmpnei": {
    "type": "instruction",
    "assemblerSyntax": "cmpnei rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits and compares it to the value of rA. If rA != \u03c3(IMM16), then cmpnei stores 1 to rB; otherwise stores 0 to rB.",
    "example": "cmpnei r6, r7, 100",
    "exceptions": "None",
    "instruction": "compare not equal immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "cmpnei",
    "operation": "if (rA != \u03c3(IMM16)) then rB \u2190 1 else rB \u2190 0",
    "usage": "cmpnei performs the != operation of the C programming language."
  },
  "custom": {
    "type": "instruction",
    "assemblerSyntax": "custom N, xC, xA, xB Where xA means either general purpose register rA, or custom register cA.",
    "description": "The custom opcode provides access to up to 256 custom instructions allowed by the Nios II architec\u2010 ture. The function implemented by a custom instruction is user-defined and is specified with the Nios_II Processor parameter editor in Qsys. The 8-bit immediate N field specifies which custom instruction to use. Custom instructions can use up to two parameters, xA and xB, and can optionally write the result to a register xC.",
    "example": "custom 0, c6, r7, r8",
    "exceptions": "None",
    "instruction": "custom instruction",
    "instructionFields": "A = Register index of operand A B = Register index of operand B C = Register index of operand C readra = 1 if instruction uses rA, 0 otherwise readrb = 1 if instruction uses rB, 0 otherwise writerc = 1 if instruction provides result for rC, 0 otherwise N = 8-bit number that selects instruction",
    "instructionType": "R",
    "mnemonic": "custom",
    "operation": "if c == 1 then rC \u2190 fN(rA, rB, A, B, C) else \u00d8 \u2190 fN(rA, rB, A, B, C)",
    "usage": "To access a custom register inside the custom instruction logic, clear the bit readra, readrb, or writerc that corresponds to the register field. In assembler syntax, the notation cN refers to register N in the custom register file and causes the assembler to clear the c bit of the opcode. For example, custom 0, c3, r5, r0 performs custom instruction 0, operating on general-purpose registers r5 and r0, and stores the result in custom register 3."
  },
  "div": {
    "type": "instruction",
    "assemblerSyntax": "div rC, rA, rB",
    "description": "Treating rA and rB as signed integers, this instruc\u2010 tion divides rA by rB and then stores the integer portion of the resulting quotient to rC. After attempted division by zero, the value of rC is undefined. There is no divide-by-zero exception. After dividing \u20132147483648 by \u20131, the value of rC is undefined (the number +2147483648 is not representable in 32 bits). There is no overflow exception. Nios II processors that do not implement the div instruction cause an unimplemented instruction exception.",
    "example": "div r6, r7, r8",
    "exceptions": "Division error Unimplemented instruction",
    "instruction": "divide",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "div",
    "operation": "rC \u2190 rA \u00f7 rB",
    "usage": "Remainder of Division:\nIf the result of the division is defined, then the remainder can be computed in rD using the following instruction sequence:\n```niosii\ndiv rC, rA, rB\nmul rD, rC, rB\nsub rD, rA, rD\n// The original div operation\n// rD = remainder\n```\n"
  },
  "divu": {
    "type": "instruction",
    "assemblerSyntax": "divu rC, rA, rB",
    "description": "Treating rA and rB as unsigned integers, this instruction divides rA by rB and then stores the integer portion of the resulting quotient to rC. After attempted division by zero, the value of rC is undefined. There is no divide-by-zero exception. Nios II processors that do not implement the divu instruction cause an unimplemented instruction exception.",
    "example": "divu r6, r7, r8",
    "exceptions": "Division error Unimplemented instruction",
    "instruction": "divide unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "divu",
    "operation": "rC \u2190 rA \u00f7 rB",
    "usage": "Remainder of Division:\nIf the result of the division is defined, then the remainder can be computed in rD using the following instruction sequence:\n```niosii\ndivu rC, rA, rB\nmul rD, rC, rB\nsub rD, rA, rD\n// The original divu operation\n// rD = remainder\n```\n"
  },
  "eret": {
    "type": "instruction",
    "assemblerSyntax": "eret",
    "description": "Copies the value of estatus into the status register, and transfers execution to the address in ea.",
    "example": "eret",
    "exceptions": "Misaligned destination address Supervisor-only instruction",
    "instruction": "exception return",
    "instructionFields": "None",
    "instructionType": "R",
    "mnemonic": "eret",
    "operation": "status \u2190 estatus PC \u2190 ea",
    "usage": "Use eret to return from traps, external interrupts, and other exception handling routines. Note that before returning from hardware interrupt exceptions, the exception handler must adjust the ea register."
  },
  "flushd": {
    "type": "instruction",
    "assemblerSyntax": "flushd IMM16(rA)",
    "description": "If the Nios II processor implements a direct mapped data cache, flushd writes the data cache line that is mapped to the specified address back to memory if the line is dirty, and then clears the data cache line. Unlike flushda, flushd writes the dirty data back to memory even when the addressed data is not currently in the cache. This process comprises the following steps:\nsum of rA and the signed 16-bit immediate value. computed effective address. Each data cache effective address comprises a tag field and a line field. When identifying the data cache line, flushd ignores the tag field and only uses the line field to select the data cache line to clear. effective address to determine if the addressed data is currently cached. Because flushd ignores the cache line tag, flushd flushes the cache line regardless of whether the specified data location is currently cached. to memory. A cache line is dirty when one or more words of the cache line have been modified by the processor, but are not yet written to memory. If the Nios II processor core does not have a data cache, the flushd instruction performs no operation.",
    "example": "flushd -100(r6)",
    "exceptions": "None",
    "instruction": "flush data cache line",
    "instructionFields": "A = Register index of operand rA IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "flushd",
    "operation": "Flushes the data cache line associated with address rA + \u03c3(IMM16).",
    "usage": "Use flushd to write dirty lines back to memory even if the addressed memory location is not in the cache, and then flush the cache line. By contrast, refer to \u201cflushda flush data cache address\u201d, \u201cinitd initialize data cache line\u201d, and \u201cinitda initialize data cache address\u201d for other cache-clearing options. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "flushda": {
    "type": "instruction",
    "assemblerSyntax": "flushda IMM16(rA)",
    "description": "If the Nios II processor implements a direct mapped data cache, flushda writes the data cache line that is mapped to the specified address back to memory if the line is dirty, and then clears the data cache line. Unlike flushd, flushda writes the dirty data back to memory only when the addressed data is currently in the cache. This process comprises the following steps:\nsum of rA and the signed 16-bit immediate value. computed effective address. Each data cache effective address comprises a tag field and a line field. When identifying the line, flushda uses both the tag field and the line field. address to determine if the addressed data is currently cached. If the tag fields do not match, the effective address is not currently cached, so the instruction does nothing. match, write the dirty cache line back to memory. A cache line is dirty when one or more words of the cache line have been modified by the processor, but are not yet written to memory. If the Nios II processor core does not have a data cache, the flushda instruction performs no operation.",
    "example": "flushda -100(r6)",
    "exceptions": "Supervisor-only data address Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "flush data cache address",
    "instructionFields": "A = Register index of operand rA IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "flushda",
    "operation": "Flushes the data cache line currently caching address rA + \u03c3(IMM16)",
    "usage": "Use flushda to write dirty lines back to memory only if the addressed memory location is currently in the cache, and then flush the cache line. By contrast, refer to \u201cflushd flush data cache line\u201d, \u201cinitd initialize data cache line\u201d, and \u201cinitda initialize data cache address\u201d for other cache-clearing options. For more information on the Nios II data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "flushi": {
    "type": "instruction",
    "assemblerSyntax": "flushi rA",
    "description": "Ignoring the tag, flushi identifies the instruction cache line associated with the byte address in rA, and invalidates that line. If the Nios II processor core does not have an instruction cache, the flushi instruction performs no operation. For more information about the data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook.",
    "example": "flushi r6",
    "exceptions": "None",
    "instruction": "flush instruction cache line",
    "instructionFields": "A = Register index of operand rA",
    "instructionType": "R",
    "mnemonic": "flushi",
    "operation": "Flushes the instruction cache line associated with address rA."
  },
  "flushp": {
    "type": "instruction",
    "assemblerSyntax": "flushp",
    "description": "Ensures that any instructions prefetched after the flushp instruction are removed from the pipeline.",
    "example": "flushp",
    "exceptions": "None",
    "instruction": "flush pipeline",
    "instructionFields": "None",
    "instructionType": "R",
    "mnemonic": "flushp",
    "operation": "Flushes the processor pipeline of any prefetched instructions.",
    "usage": "Use flushp before transferring control to newly updated instruction memory."
  },
  "initd": {
    "type": "instruction",
    "assemblerSyntax": "initd IMM16(rA)",
    "description": "If the Nios II processor implements a direct mapped data cache, initd clears the data cache line without checking for (or writing) a dirty data cache line that is mapped to the specified address back to memory. Unlike initda, initd clears the cache line regardless of whether the addressed data is currently cached. This process comprises the following steps:\nsum of rA and the signed 16-bit immediate value. computed effective address. Each data cache effective address comprises a tag field and a line field. When identifying the line, initd ignores the tag field and only uses the line field to select the data cache line to clear. effective address to determine if the addressed data is currently cached. Because initd ignores the cache line tag, initd flushes the cache line regardless of whether the specified data location is currently cached. Because initd skips the dirty cache line check, data that has been modified by the processor, but not yet written to memory is lost. If the Nios II processor core does not have a data cache, the initd instruction performs no operation.",
    "example": "initd 0(r6)",
    "exceptions": "Supervisor-only instruction",
    "instruction": "initialize data cache line",
    "instructionFields": "A = Register index of operand rA IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "initd",
    "operation": "Initializes the data cache line associated with address rA + \u03c3(IMM16).",
    "usage": "Use initd after processor reset and before accessing data memory to initialize the processor\u2019s data cache. Use initd with caution because it does not write back dirty data. By contrast, refer to \u201cflushd flush data cache line\u201d, \u201cflushda flush data cache address\u201d, and \u201cinitda initialize data cache address\u201d for other cache-clearing options. Altera recommends using initd only when the processor comes out of reset. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "initda": {
    "type": "instruction",
    "assemblerSyntax": "initda IMM16(rA)",
    "description": "If the Nios II processor implements a direct mapped data cache, initda clears the data cache line without checking for (or writing) a dirty data cache line that is mapped to the specified address back to memory. Unlike initd, initda clears the cache line only when the addressed data is currently cached. This process comprises the following steps:\nsum of rA and the signed 16-bit immediate value. computed effective address. Each data cache effective address comprises a tag field and a line field. When identifying the line, initda uses both the tag field and the line field. address to determine if the addressed data is currently cached. If the tag fields do not match, the effective address is not currently cached, so the instruction does nothing. Because initd skips the dirty cache line check, data that has been modified by the processor, but not yet written to memory is lost. If the Nios II processor core does not have a data cache, the initda instruction performs no operation.",
    "example": "initda -100(r6)",
    "exceptions": "Supervisor-only data address Fast TLB miss (data) Double TLB miss (data) MPU region violation (data) Unimplemented instruction",
    "instruction": "initialize data cache address",
    "instructionFields": "A = Register index of operand rA IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "initda",
    "operation": "Initializes the data cache line currently caching address rA + \u03c3(IMM16)",
    "usage": "Use initda to skip writing dirty lines back to memory and to flush the cache line only if the addressed memory location is currently in the cache. By contrast, refer to \u201cflushd flush data cache line\u201d, \u201cflushda flush data cache address\u201d, and \u201cinitd initialize data cache line\u201d on page 8\u201355 for other cache-clearing options. Use initda with caution because it does not write back dirty data. For more information on the Nios II data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "initi": {
    "type": "instruction",
    "assemblerSyntax": "initi rA",
    "description": "Ignoring the tag, initi identifies the instruction cache line associated with the byte address in ra, and initi invalidates that line. If the Nios II processor core does not have an instruction cache, the initi instruction performs no operation.",
    "example": "initi r6",
    "exceptions": "Supervisor-only instruction",
    "instruction": "initialize instruction cache line",
    "instructionFields": "A = Register index of operand rA",
    "instructionType": "R",
    "mnemonic": "initi",
    "operation": "Initializes the instruction cache line associated with address rA.",
    "usage": "This instruction is used to initialize the processor\u2019s instruction cache. Immediately after processor reset, use initi to invalidate each line of the instruction cache. For more information on instruction cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "jmp": {
    "type": "instruction",
    "assemblerSyntax": "jmp rA",
    "description": "Transfers execution to the address contained in register rA.",
    "example": "jmp r12",
    "exceptions": "Misaligned destination address",
    "instruction": "computed jump",
    "instructionFields": "A = Register index of operand rA",
    "instructionType": "R",
    "mnemonic": "jmp",
    "operation": "PC \u2190 rA",
    "usage": "It is illegal to jump to the address contained in register r31. To return from subroutines called by call or callr, use ret instead of jmp."
  },
  "jmpi": {
    "type": "instruction",
    "assemblerSyntax": "jmpi label",
    "description": "Transfers execution to the instruction at address (PC31..28 : IMM26 x 4).",
    "example": "jmpi write_char",
    "exceptions": "None",
    "instruction": "jump immediate",
    "instructionFields": "IMM26 = 26-bit unsigned immediate value",
    "instructionType": "J",
    "mnemonic": "jmpi",
    "operation": "PC \u2190 (PC31..28 : IMM26 x 4)",
    "usage": "jmpi is a low-overhead local jump. jmpi can transfer execution anywhere within the 256-MB range determined by PC31..28. The Nios II GNU linker does not automatically handle cases in which the address is out of this range."
  },
  "ldb / ldbio": {
    "type": "instruction",
    "assemblerSyntax": "ldb rB, byte_offset(rA)\nldbio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Loads register rB with the desired memory byte, sign extending the 8-bit value to 32 bits. In Nios II processor cores with a data cache, this instruction may retrieve the desired data from the cache instead of from memory.",
    "example": "ldb r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (read) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "load byte from memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 9: ldb",
    "instructionType": "I",
    "mnemonic": "ldb / ldbio",
    "operation": "rB \u2190 \u03c3(Mem8[rA + \u03c3(IMM16)])",
    "usage": "Use the ldbio instruction for peripheral I/O. In processors with a data cache, ldbio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, ldbio acts like ldb. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "ldbu / ldbuio": {
    "type": "instruction",
    "assemblerSyntax": "ldbu rB, byte_offset(rA)\nldbuio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Loads register rB with the desired memory byte, zero extending the 8-bit value to 32 bits.",
    "example": "ldbu r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (read) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "load unsigned byte from memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 11: ldbu",
    "instructionType": "I",
    "mnemonic": "ldbu / ldbuio",
    "operation": "rB \u2190 0x000000 : Mem8[rA + \u03c3(IMM16)]",
    "usage": "In processors with a data cache, this instruction may retrieve the desired data from the cache instead of from memory. Use the ldbuio instruction for peripheral I/O. In processors with a data cache, ldbuio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, ldbuio acts like ldbu. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "ldh / ldhio": {
    "type": "instruction",
    "assemblerSyntax": "ldh rB, byte_offset(rA)\nldhio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Loads register rB with the memory halfword located at the effective byte address, sign extending the 16-bit value to 32 bits. The effective byte address must be halfword aligned. If the byte address is not a multiple of 2, the operation is undefined.",
    "example": "ldh r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (read) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "load halfword from memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 13: ldh",
    "instructionType": "I",
    "mnemonic": "ldh / ldhio",
    "operation": "rB \u2190 \u03c3(Mem16[rA + \u03c3(IMM16)])",
    "usage": "In processors with a data cache, this instruction may retrieve the desired data from the cache instead of from memory. Use the ldhio instruction for peripheral I/O. In processors with a data cache, ldhio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, ldhio acts like ldh. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "ldhu / ldhuio": {
    "type": "instruction",
    "assemblerSyntax": "ldhu rB, byte_offset(rA)\nldhuio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Loads register rB with the memory halfword located at the effective byte address, zero extending the 16-bit value to 32 bits. The effective byte address must be halfword aligned. If the byte address is not a multiple of 2, the operation is undefined.",
    "example": "ldhu r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (read) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "load unsigned halfword from memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 15: ldhu",
    "instructionType": "I",
    "mnemonic": "ldhu / ldhuio",
    "operation": "rB \u2190 0x0000 : Mem16[rA + \u03c3(IMM16)]",
    "usage": "In processors with a data cache, this instruction may retrieve the desired data from the cache instead of from memory. Use the ldhuio instruction for peripheral I/O. In processors with a data cache, ldhuio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, ldhuio acts like ldhu. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "ldw / ldwio": {
    "type": "instruction",
    "assemblerSyntax": "ldw rB, byte_offset(rA)\nldwio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Loads register rB with the memory word located at the effective byte address. The effective byte address must be word aligned. If the byte address is not a multiple of 4, the operation is undefined.",
    "example": "ldw r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (read) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "load 32-bit word from memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 17: ldw",
    "instructionType": "I",
    "mnemonic": "ldw / ldwio",
    "operation": "rB \u2190 Mem32[rA + \u03c3(IMM14)]",
    "usage": "In processors with a data cache, this instruction may retrieve the desired data from the cache instead of from memory. Use the ldwio instruction for peripheral I/O. In processors with a data cache, ldwio bypasses the cache and memory. Use the ldwio instruction for peripheral I/O. In processors with a data cache, ldwio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, ldwio acts like ldw. For more information on data cache, refer to the Cache and Tightly Coupled Memory chapter of the Nios II Software Developer\u2019s Handbook."
  },
  "mov": {
    "type": "instruction",
    "assemblerSyntax": "mov rC, rA",
    "description": "Moves the contents of rA to rC. Pseudo-instruction mov is implemented as add rC, rA, r0.",
    "example": "mov r6, r7",
    "instruction": "move register to register",
    "mnemonic": "mov",
    "operation": "rC \u2190 rA"
  },
  "movhi": {
    "type": "instruction",
    "assemblerSyntax": "movhi rB, IMMED",
    "description": "Writes the immediate value IMMED into the high halfword of rB, and clears the lower halfword of rB to 0x0000.",
    "example": "movhi r6, 0x8000",
    "instruction": "move immediate into high halfword",
    "mnemonic": "movhi",
    "operation": "rB \u2190 (IMMED : 0x0000)",
    "usage": "The maximum allowed value of IMMED is 65535. The minimum allowed value is 0. To load a 32-bit constant into a register, first load the upper 16 bits using a movhi pseudo-instruction. The %hi() macro can be used to extract the upper 16 bits of a constant or a label. Then, load the lower 16 bits with an ori instruction. The %lo() macro can be used to extract the lower 16 bits of a constant or label as shown in the following code:\n```niosii\nmovhi rB, %hi(value)\nori rB, rB, %lo(value)\n```\n An alternative method to load a 32-bit constant into a register uses the %hiadj() macro and the addi instruction as shown in the following code:\n```niosii\nmovhi rB, %hiadj(value)\naddi rB, rB, %lo(value)\n```\n Pseudo-instruction movhi is implemented as orhi rB, r0, IMMED."
  },
  "movi": {
    "type": "instruction",
    "assemblerSyntax": "movi rB, IMMED",
    "description": "Sign-extends the immediate value IMMED to 32 bits and writes it to rB.",
    "example": "movi r6, -30",
    "instruction": "move signed immediate into word",
    "mnemonic": "movi",
    "operation": "rB \u2190 \u03c3(IMMED)",
    "usage": "The maximum allowed value of IMMED is 32767. The minimum allowed value is \u201332768. To load a 32-bit constant into a register, refer to the movhi instruction. Pseudo-instruction movi is implemented as addi rB, r0, IMMED."
  },
  "movia": {
    "type": "instruction",
    "assemblerSyntax": "movia rB, label",
    "description": "Writes the address of label to rB. Pseudo-instruction movia is implemented as:\n```niosii\norhi rB, r0, %hiadj(label)\naddi rB, rB, %lo(label)",
    "example": "movia r6, function_address",
    "instruction": "move immediate address into word",
    "mnemonic": "movia",
    "operation": "rB \u2190 label"
  },
  "movui": {
    "type": "instruction",
    "assemblerSyntax": "movui rB, IMMED",
    "description": "Zero-extends the immediate value IMMED to 32 bits and writes it to rB.",
    "example": "movui r6, 100",
    "instruction": "move unsigned immediate into word",
    "mnemonic": "movui",
    "operation": "rB \u2190 (0x0000 : IMMED)",
    "usage": "The maximum allowed value of IMMED is 65535. The minimum allowed value is 0. To load a 32-bit constant into a register, refer to the movhi instruc\u2010 tion. Pseudo-instruction movui is implemented as ori rB, r0, IMMED."
  },
  "mul": {
    "type": "instruction",
    "assemblerSyntax": "mul rC, rA, rB",
    "description": "Multiplies rA times rB and stores the 32 low-order bits of the product to rC. The result is the same whether the operands are treated as signed or unsigned integers. Nios II processors that do not implement the mul instruction cause an unimplemented instruction exception.",
    "example": "mul r6, r7, r8",
    "exceptions": "Unimplemented instruction",
    "instruction": "multiply",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "mul",
    "operation": "rC \u2190 (rA x rB) 31..0",
    "usage": "Carry Detection (unsigned operands):\nBefore or after the multiply operation, the carry out of the MSB of rC can be detected using the following instruction sequence:\n```niosii\nmul rC, rA, rB\nmulxuu rD, rA, rB\ncmpne rD, rD, r0\n// The mul operation (optional)\n// rD is nonzero if carry occurred\n// rD is 1 if carry occurred, 0 if not\n```\n The mulxuu instruction writes a nonzero value into rD if the multiplication of unsigned numbers generates a carry (unsigned overflow). If a 0/1 result is desired, follow the mulxuu with the cmpne instruction. Overflow Detection (signed operands):\nAfter the multiply operation, overflow can be detected using the following instruction sequence:\n```niosii\nmul rC, rA, rB\ncmplt rD, rC, r0\nmulxss rE, rA, rB\nadd rD, rD, rE\ncmpne rD, rD, r0\n// The original mul operation\n// rD is nonzero if overflow\n// rD is 1 if overflow, 0 if not\n```\n The cmplt\u2013mulxss\u2013add instruction sequence writes a nonzero value into rD if the product in rC cannot be represented in 32 bits (signed overflow). If a 0/1 result is desired, follow the instruction sequence with the cmpne instruction."
  },
  "muli": {
    "type": "instruction",
    "assemblerSyntax": "muli rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits and multiplies it by the value of rA. Stores the 32 low-order bits of the product to rB. The result is independent of whether rA is treated as a signed or unsigned number. Nios II processors that do not implement the muli instruction cause an unimplemented instruction exception. Carry Detection and Overflow Detection:\nFor a discussion of carry and overflow detection, refer to the mul instruction.",
    "example": "muli r6, r7, -100",
    "exceptions": "Unimplemented instruction",
    "instruction": "multiply immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "muli",
    "operation": "rB \u2190 (rA x \u03c3(IMM16)) 31..0"
  },
  "mulxss": {
    "type": "instruction",
    "assemblerSyntax": "mulxss rC, rA, rB",
    "description": "Treating rA and rB as signed integers, mulxss multiplies rA times rB, and stores the 32 high-order bits of the product to rC. Nios II processors that do not implement the mulxss instruction cause an unimplemented instruction exception.",
    "example": "mulxss r6, r7, r8",
    "exceptions": "Unimplemented instruction",
    "instruction": "multiply extended signed/signed",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "mulxss",
    "operation": "rC \u2190 ((signed) rA) x ((signed) rB)) 63..32",
    "usage": "Use mulxss and mul to compute the full 64-bit product of two 32-bit signed integers. Furthermore, mulxss can be used as part of the calculation of a 128-bit product of two 64-bit signed integers. Given two 64-bit integers, each contained in a pair of 32-bit registers, (S1 : U1) and (S2 : U2), their 128-bit product is (U1 x U2) + ((S1 x U2) << 32) + ((U1 x S2) << 32) + ((S1 x S2) << 64). The mulxss and mul instructions are used to calculate the 64-bit product S1 x S2."
  },
  "mulxsu": {
    "type": "instruction",
    "assemblerSyntax": "mulxsu rC, rA, rB",
    "description": "Treating rA as a signed integer and rB as an unsigned integer, mulxsu multiplies rA times rB, and stores the 32 high-order bits of the product to rC. Nios II processors that do not implement the mulxsu instruction cause an unimplemented instruction exception.",
    "example": "mulxsu r6, r7, r8",
    "exceptions": "Unimplemented instruction",
    "instruction": "multiply extended signed/unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "mulxsu",
    "operation": "rC \u2190 ((signed) rA) x ((unsigned) rB)) 63..32",
    "usage": "mulxsu can be used as part of the calculation of a 128-bit product of two 64-bit signed integers. Given two 64-bit integers, each contained in a pair of 32-bit registers, (S1 : U1) and (S2 : U2), their 128-bit product is: (U1 x U2) + ((S1 x U2) << 32) + ((U1 x S2) << 32) + ((S1 x S2) << 64). The mulxsu and mul instructions are used to calculate the two 64-bit products S1 x U2 and U1 x S2."
  },
  "mulxuu": {
    "type": "instruction",
    "assemblerSyntax": "mulxuu rC, rA, rB",
    "description": "Treating rA and rB as unsigned integers, mulxuu multiplies rA times rB and stores the 32 high-order bits of the product to rC. Nios II processors that do not implement the mulxuu instruction cause an unimplemented instruction exception.",
    "example": "mulxuu r6, r7, r8",
    "exceptions": "Unimplemented instruction",
    "instruction": "multiply extended unsigned/unsigned",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "mulxuu",
    "operation": "rC \u2190 ((unsigned) rA) x ((unsigned) rB)) 63..32",
    "usage": "Use mulxuu and mul to compute the 64-bit product of two 32-bit unsigned integers. Furthermore, mulxuu can be used as part of the calculation of a 128-bit product of two 64-bit signed integers. Given two 64-bit signed integers, each contained in a pair of 32-bit registers, (S1 : U1) and (S2 : U2), their 128-bit product is (U1 x U2) + ((S1 x U2) << 32) + ((U1 x S2) << 32) + ((S1 x S2) << 64). The mulxuu and mul instructions are used to calculate the 64-bit product U1 x U2. mulxuu also can be used as part of the calculation of a 128-bit product of two 64-bit unsigned integers. Given two 64-bit unsigned integers, each contained in a pair of 32-bit registers, (T1 : U1) and (T2 : U2), their 128-bit product is (U1 x U2) + ((U1 x T2) << 32) + ((T1 x U2) << 32) + ((T1 x T2) << 64). The mulxuu and mul instructions are used to calculate the four 64-bit products U1 x U2, U1 x T2, T1 x U2, and T1 x T2."
  },
  "nextpc": {
    "type": "instruction",
    "assemblerSyntax": "nextpc rC",
    "description": "Stores the address of the next instruction to register rC.",
    "example": "nextpc r6",
    "exceptions": "None",
    "instruction": "get address of following instruction",
    "instructionFields": "C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "nextpc",
    "operation": "rC \u2190 PC + 4",
    "usage": "A relocatable code fragment can use nextpc to calculate the address of its data segment. nextpc is the only way to access the PC directly."
  },
  "nop": {
    "type": "instruction",
    "assemblerSyntax": "nop",
    "description": "nop does nothing. Pseudo-instruction nop is implemented as add r0, r0, r0.",
    "example": "nop",
    "instruction": "no operation",
    "mnemonic": "nop",
    "operation": "None"
  },
  "nor": {
    "type": "instruction",
    "assemblerSyntax": "nor rC, rA, rB",
    "description": "Calculates the bitwise logical NOR of rA and rB and stores the result in rC.",
    "example": "nor r6, r7, r8",
    "exceptions": "None",
    "instruction": "bitwise logical nor",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "nor",
    "operation": "rC \u2190 ~(rA | rB)"
  },
  "or": {
    "type": "instruction",
    "assemblerSyntax": "or rC, rA, rB",
    "description": "Calculates the bitwise logical OR of rA and rB and stores the result in rC.",
    "example": "or r6, r7, r8",
    "exceptions": "None",
    "instruction": "bitwise logical or",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "or",
    "operation": "rC \u2190 rA | rB"
  },
  "orhi": {
    "type": "instruction",
    "assemblerSyntax": "orhi rB, rA, IMM16",
    "description": "Calculates the bitwise logical OR of rA and (IMM16 : 0x0000) and stores the result in rB.",
    "example": "orhi r6, r7, 100",
    "exceptions": "None",
    "instruction": "bitwise logical or immediate into high halfword",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "orhi",
    "operation": "rB \u2190 rA | (IMM16 : 0x0000)"
  },
  "ori": {
    "type": "instruction",
    "assemblerSyntax": "ori rB, rA, IMM16",
    "description": "Calculates the bitwise logical OR of rA and (0x0000 : IMM16) and stores the result in rB.",
    "example": "ori r6, r7, 100",
    "exceptions": "None",
    "instruction": "bitwise logical or immediate",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "ori",
    "operation": "rB \u2190 rA | (0x0000 : IMM16)"
  },
  "rdctl": {
    "type": "instruction",
    "assemblerSyntax": "rdctl rC, ctlN",
    "description": "Reads the value contained in control register ctlN and writes it to register rC.",
    "example": "rdctl r3, ctl31",
    "exceptions": "Supervisor-only instruction",
    "instruction": "read from control register",
    "instructionFields": "C = Register index of operand rC N = Control register index of operand ctlN",
    "instructionType": "R",
    "mnemonic": "rdctl",
    "operation": "rC \u2190 ctlN"
  },
  "rdprs": {
    "type": "instruction",
    "assemblerSyntax": "rdprs rB, rA, IMM16",
    "description": "Sign-extends the 16-bit immediate value IMM16 to 32 bits, and adds it to the value of rA from the previous register set. Places the result in rB in the current register set.",
    "example": "rdprs r6, r7, 0",
    "exceptions": "Supervisor-only instruction Illegal instruction",
    "instruction": "read from previous register set",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value",
    "instructionType": "I",
    "mnemonic": "rdprs",
    "operation": "rB \u2190 prs.rA + \u03c3(IMM16)",
    "usage": "The previous register set is specified by status.PRS. By default, status.PRS indicates the register set in use before an exception, such as an external interrupt, caused a register set change. To read from an arbitrary register set, software can insert the desired register set number in status.PRS prior to executing rdprs. If shadow register sets are not implemented on the Nios II core, rdprs is an illegal instruction."
  },
  "ret": {
    "type": "instruction",
    "assemblerSyntax": "ret",
    "description": "Transfers execution to the address in ra.",
    "example": "ret",
    "exceptions": "Misaligned destination address",
    "instruction": "return from subroutine",
    "instructionFields": "None",
    "instructionType": "R",
    "mnemonic": "ret",
    "operation": "PC \u2190 ra",
    "usage": "Any subroutine called by call or callr must use ret to return."
  },
  "rol": {
    "type": "instruction",
    "assemblerSyntax": "rol rC, rA, rB",
    "description": "Rotates rA left by the number of bits specified in rB4..0 and stores the result in rC. The bits that shift out of the register rotate into the least-significant bit positions. Bits 31\u20135 of rB are ignored.",
    "example": "rol r6, r7, r8",
    "exceptions": "None",
    "instruction": "rotate left",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "rol",
    "operation": "rC \u2190 rA rotated left rB4..0 bit positions"
  },
  "roli": {
    "type": "instruction",
    "assemblerSyntax": "roli rC, rA, IMM5",
    "description": "Rotates rA left by the number of bits specified in IMM5 and stores the result in rC. The bits that shift out of the register rotate into the least-significant bit positions.",
    "example": "roli r6, r7, 3",
    "exceptions": "None",
    "instruction": "rotate left immediate",
    "instructionFields": "A = Register index of operand rA C = Register index of operand rC IMM5 = 5-bit unsigned immediate value",
    "instructionType": "R",
    "mnemonic": "roli",
    "operation": "rC \u2190 rA rotated left IMM5 bit positions",
    "usage": "In addition to the rotate-left operation, roli can be used to implement a rotate-right operation. Rotating left by (32 \u2013 IMM5) bits is the equivalent of rotating right by IMM5 bits."
  },
  "ror": {
    "type": "instruction",
    "assemblerSyntax": "ror rC, rA, rB",
    "description": "Rotates rA right by the number of bits specified in rB4..0 and stores the result in rC. The bits that shift out of the register rotate into the most-significant bit positions. Bits 31\u2013 5 of rB are ignored.",
    "example": "ror r6, r7, r8",
    "exceptions": "None",
    "instruction": "rotate right",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "ror",
    "operation": "rC \u2190 rA rotated right rB4..0 bit positions"
  },
  "sll": {
    "type": "instruction",
    "assemblerSyntax": "sll rC, rA, rB",
    "description": "Shifts rA left by the number of bits specified in rB4..0 (inserting zeroes), and then stores the result in rC. sll performs the << operation of the C program\u2010 ming language.",
    "example": "sll r6, r7, r8",
    "exceptions": "None",
    "instruction": "shift left logical",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "sll",
    "operation": "rC \u2190 rA << (rB4..0)"
  },
  "slli": {
    "type": "instruction",
    "assemblerSyntax": "slli rC, rA, IMM5",
    "description": "Shifts rA left by the number of bits specified in IMM5 (inserting zeroes), and then stores the result in rC.",
    "example": "slli r6, r7, 3",
    "exceptions": "None",
    "instruction": "shift left logical immediate",
    "instructionFields": "A = Register index of operand rA C = Register index of operand rC IMM5 = 5-bit unsigned immediate value",
    "instructionType": "R",
    "mnemonic": "slli",
    "operation": "rC \u2190 rA << IMM5",
    "usage": "slli performs the << operation of the C program\u2010 ming language."
  },
  "sra": {
    "type": "instruction",
    "assemblerSyntax": "sra rC, rA, rB",
    "description": "Shifts rA right by the number of bits specified in rB4..0 (duplicating the sign bit), and then stores the result in rC. Bits 31\u20135 are ignored.",
    "example": "sra r6, r7, r8",
    "exceptions": "None",
    "instruction": "shift right arithmetic",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "sra",
    "operation": "rC \u2190 (signed) rA >> ((unsigned) rB4..0)",
    "usage": "sra performs the signed >> operation of the C programming language."
  },
  "srai": {
    "type": "instruction",
    "assemblerSyntax": "srai rC, rA, IMM5",
    "description": "Shifts rA right by the number of bits specified in IMM5 (duplicating the sign bit), and then stores the result in rC.",
    "example": "srai r6, r7, 3",
    "exceptions": "None",
    "instruction": "shift right arithmetic immediate",
    "instructionFields": "A = Register index of operand rA C = Register index of operand rC IMM5 = 5-bit unsigned immediate value",
    "instructionType": "R",
    "mnemonic": "srai",
    "operation": "rC \u2190 (signed) rA >> ((unsigned) IMM5)",
    "usage": "srai performs the signed >> operation of the C programming language."
  },
  "srl": {
    "type": "instruction",
    "assemblerSyntax": "srl rC, rA, rB",
    "description": "Shifts rA right by the number of bits specified in rB4..0 (inserting zeroes), and then stores the result in rC. Bits 31\u20135 are ignored.",
    "example": "srl r6, r7, r8",
    "exceptions": "None",
    "instruction": "shift right logical",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "srl",
    "operation": "rC \u2190 (unsigned) rA >> ((unsigned) rB4..0)",
    "usage": "srl performs the unsigned >> operation of the C programming language."
  },
  "srli": {
    "type": "instruction",
    "assemblerSyntax": "srli rC, rA, IMM5",
    "description": "Shifts rA right by the number of bits specified in IMM5 (inserting zeroes), and then stores the result in rC.",
    "example": "srli r6, r7, 3",
    "exceptions": "None",
    "instruction": "shift right logical immediate",
    "instructionFields": "A = Register index of operand rA C = Register index of operand rC IMM5 = 5-bit unsigned immediate value",
    "instructionType": "R",
    "mnemonic": "srli",
    "operation": "rC \u2190 (unsigned) rA >> ((unsigned) IMM5)",
    "usage": "srli performs the unsigned >> operation of the C programming language."
  },
  "sth / sthio": {
    "type": "instruction",
    "assemblerSyntax": "sth rB, byte_offset(rA)\nsthio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Stores the low halfword of rB to the memory location specified by the effective byte address. The effective byte address must be halfword aligned. If the byte address is not a multiple of 2, the operation is undefined.",
    "example": "sth r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (write) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "store halfword to memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 21: sth",
    "instructionType": "I",
    "mnemonic": "sth / sthio",
    "operation": "Mem16[rA + \u03c3(IMM16)] \u2190 rB15..0",
    "usage": "In processors with a data cache, this instruction may not generate an Avalon-MM data transfer immediately. Use the sthio instruction for peripheral I/O. In processors with a data cache, sthio bypasses the cache and is guaranteed to generate an Avalon-MM data transfer. In processors without a data cache, sthio acts like sth."
  },
  "stw / stwio": {
    "type": "instruction",
    "assemblerSyntax": "stw rB, byte_offset(rA)\nstwio rB, byte_offset(rA)",
    "description": "Computes the effective byte address specified by the sum of rA and the instruction's signed 16-bit immediate value. Stores rB to the memory location specified by the effective byte address. The effective byte address must be word aligned. If the byte address is not a multiple of 4, the operation is undefined.",
    "example": "stw r6, 100(r5)",
    "exceptions": "Supervisor-only data address Misaligned data address TLB permission violation (write) Fast TLB miss (data) Double TLB miss (data) MPU region violation (data)",
    "instruction": "store word to memory or I/O peripheral",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit signed immediate value Table 23: stw",
    "instructionType": "I",
    "mnemonic": "stw / stwio",
    "operation": "Mem32[rA + \u03c3(IMM16)] \u2190 rB",
    "usage": "In processors with a data cache, this instruction may not generate an Avalon-MM data transfer immediately. Use the stwio instruction for peripheral I/O. In processors with a data cache, stwio bypasses the cache and is guaranteed to generate an Avalon-MM bus cycle. In processors without a data cache, stwio acts like stw."
  },
  "sub": {
    "type": "instruction",
    "assemblerSyntax": "sub rC, rA, rB",
    "description": "Subtract rB from rA and store the result in rC.",
    "example": "sub r6, r7, r8",
    "exceptions": "None",
    "instruction": "subtract",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "sub",
    "operation": "rC \u2190 rA \u2013 rB",
    "usage": "Carry Detection (unsigned operands):\nThe carry bit indicates an unsigned overflow. Before or after a sub operation, a carry out of the MSB can be detected by checking whether the first operand is less than the second operand. The carry bit can be written to a register, or a conditional branch can be taken based on the carry condition. Both cases are shown in the following code:\n```niosii\nsub rC, rA, rB\ncmpltu rD, rA, rB\nsub rC, rA, rB\nbltu rA, rB, label\n// The original sub operation (optional)\n// rD is written with the carry bit\n// The original sub operation (optional)\n// Branch if carry generated\n```\n Overflow Detection (signed operands):\nDetect overflow of signed subtraction by comparing the sign of the difference that is written to rC with the signs of the operands. If rA and rB have different signs, and the sign of rC is different than the sign of rA, an overflow occurred. The overflow condition can control a conditional branch, as shown in the following code:\n```niosii\nsub rC, rA, rB\nxor rD, rA, rB\nxor rE, rA, rC\nand rD, rD, rE\nblt rD, r0, label\n// The original sub operation\n// Compare signs of rA and rB\n// Compare signs of rA and rC\n// Combine comparisons\n// Branch if overflow occurred\n```\n"
  },
  "subi": {
    "type": "instruction",
    "assemblerSyntax": "subi rB, rA, IMMED",
    "description": "Sign-extends the immediate value IMMED to 32 bits, subtracts it from the value of rA and then stores the result in rB.",
    "example": "subi r8, r8, 4",
    "instruction": "subtract immediate",
    "mnemonic": "subi",
    "operation": "rB \u2190 rA \u2013 \u03c3(IMMED)",
    "usage": "The maximum allowed value of IMMED is 32768. The minimum allowed value is \u201332767. Pseudo-instruction subi is implemented as addi rB, rA, -IMMED"
  },
  "sync": {
    "type": "instruction",
    "assemblerSyntax": "sync",
    "description": "Forces all pending memory accesses to complete before allowing execution of subsequent instruc\u2010 tions. In processor cores that support in-order memory accesses only, this instruction performs no operation.",
    "example": "sync",
    "exceptions": "None",
    "instruction": "memory synchronization",
    "instructionFields": "None",
    "instructionType": "R",
    "mnemonic": "sync",
    "operation": "None"
  },
  "trap": {
    "type": "instruction",
    "assemblerSyntax": "trap\ntrap imm5",
    "description": "Saves the address of the next instruction in register ea, saves the contents of the status register in estatus, disables interrupts, and transfers execution to the exception handler. The address of the exception handler is specified with the Nios_II Processor parameter editor in Qsys. The 5-bit immediate field imm5 is ignored by the processor, but it can be used by the debugger. trap with no argument is the same as trap 0.",
    "example": "trap",
    "exceptions": "Trap",
    "instruction": "trap",
    "instructionFields": "IMM5 = Type of breakpoint",
    "instructionType": "R",
    "mnemonic": "trap",
    "operation": "estatus \u2190 status PIE \u2190 0 U \u2190 0 ea \u2190 PC + 4 PC \u2190 exception handler address",
    "usage": "To return from the exception handler, execute an eret instruction."
  },
  "wrctl": {
    "type": "instruction",
    "assemblerSyntax": "wrctl ctlN, rA",
    "description": "Writes the value contained in register rA to the control register ctlN.",
    "example": "wrctl ctl6, r3",
    "exceptions": "Supervisor-only instruction",
    "instruction": "write to control register",
    "instructionFields": "A = Register index of operand rA N = Control register index of operand ctlN",
    "instructionType": "R",
    "mnemonic": "wrctl",
    "operation": "ctlN \u2190 rA"
  },
  "wrprs": {
    "type": "instruction",
    "assemblerSyntax": "wrprs rC, rA",
    "description": "Copies the value of rA in the current register set to rC in the previous register set. This instruction can set r0 to 0 in a shadow register set.",
    "example": "wrprs r6, r7",
    "exceptions": "Supervisor-only instruction Illegal instruction",
    "instruction": "write to previous register set",
    "instructionFields": "A = Register index of operand rA C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "wrprs",
    "operation": "prs.rC \u2190 rA",
    "usage": "The previous register set is specified by status.PRS. By default, status.PRS indicates the register set in use before an exception, such as an external interrupt, caused a register set change. To write to an arbitrary register set, software can insert the desired register set number in status.PRS prior to executing wrprs. System software must use wrprs to initialize r0 to 0 in each shadow register set before using that register set. If shadow register sets are not implemented on the Nios II core, wrprs is an illegal instruction."
  },
  "xor": {
    "type": "instruction",
    "assemblerSyntax": "xor rC, rA, rB",
    "description": "Calculates the bitwise logical exclusive-or of rA and rB and stores the result in rC.",
    "example": "xor r6, r7, r8",
    "exceptions": "None",
    "instruction": "bitwise logical exclusive or",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB C = Register index of operand rC",
    "instructionType": "R",
    "mnemonic": "xor",
    "operation": "rC \u2190 rA ^ rB"
  },
  "xorhi": {
    "type": "instruction",
    "assemblerSyntax": "xorhi rB, rA, IMM16",
    "description": "Calculates the bitwise logical exclusive XOR of rA and (IMM16 : 0x0000) and stores the result in rB.",
    "example": "xorhi r6, r7, 100",
    "exceptions": "None",
    "instruction": "bitwise logical exclusive or immediate into high halfword",
    "instructionFields": "A = Register index of operand rA B = Register index of operand rB IMM16 = 16-bit unsigned immediate value",
    "instructionType": "I",
    "mnemonic": "xorhi",
    "operation": "rB \u2190 rA ^ (IMM16 : 0x0000)"
  },
  "r0 / zero": {
    "type": "register",
    "function": "0x00000000",
    "name": "r0 / zero"
  },
  "r1 / at": {
    "type": "register",
    "function": "Assembler temporary",
    "name": "r1 / at"
  },
  "r2": {
    "type": "register",
    "function": "Return value",
    "name": "r2"
  },
  "r3": {
    "type": "register",
    "function": "Return value",
    "name": "r3"
  },
  "r4": {
    "type": "register",
    "function": "Register arguments",
    "name": "r4"
  },
  "r5": {
    "type": "register",
    "function": "Register arguments",
    "name": "r5"
  },
  "r6": {
    "type": "register",
    "function": "Register arguments",
    "name": "r6"
  },
  "r7": {
    "type": "register",
    "function": "Register arguments",
    "name": "r7"
  },
  "r8": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r8"
  },
  "r9": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r9"
  },
  "r10": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r10"
  },
  "r11": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r11"
  },
  "r12": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r12"
  },
  "r13": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r13"
  },
  "r14": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r14"
  },
  "r15": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r15"
  },
  "r16": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r16"
  },
  "r17": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r17"
  },
  "r18": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r18"
  },
  "r19": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r19"
  },
  "r20": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r20"
  },
  "r21": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r21"
  },
  "r22": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r22"
  },
  "r23": {
    "type": "register",
    "function": "Caller-saved register",
    "name": "r23"
  },
  "r24 / et": {
    "type": "register",
    "function": "Exception temporary",
    "name": "r24 / et"
  },
  "r25 / bt": {
    "type": "register",
    "function": "Breakpoint temporary",
    "name": "r25 / bt"
  },
  "r26 / gb": {
    "type": "register",
    "function": "Global pointer",
    "name": "r26 / gb"
  },
  "r27 / sp": {
    "type": "register",
    "function": "Stack pointer",
    "name": "r27 / sp"
  },
  "r28 / fp": {
    "type": "register",
    "function": "Frame pointer",
    "name": "r28 / fp"
  },
  "r29 / ea": {
    "type": "register",
    "function": "Exception return address",
    "name": "r29 / ea"
  },
  "r30 / sstatus": {
    "type": "register",
    "function": "Status register",
    "name": "r30 / sstatus"
  },
  "r31 / ra": {
    "type": "register",
    "function": "Return address",
    "name": "r31 / ra"
  },
  ".abort": {
    "type": "directive",
    "description": "This directive stops the assembly immediately. It is for compatibility with other assemblers. The original idea was that the assembly language source would be piped into the assembler. If the sender of the source quit, it could use this directive tells as to quit also. One day `.abort` will not be supported.",
    "name": ".abort",
    "usage": ".abort"
  },
  ".section": {
    "type": "directive",
    "description": "Use the .section directive to assemble the following code into a section named *name*.",
    "name": ".section",
    "usage": ".section *name*"
  },
  "ldb": {
    "type": "alias",
    "alias": "ldb / ldbio"
  },
  "ldbio": {
    "type": "alias",
    "alias": "ldb / ldbio"
  },
  "ldbu": {
    "type": "alias",
    "alias": "ldbu / ldbuio"
  },
  "ldbuio": {
    "type": "alias",
    "alias": "ldbu / ldbuio"
  },
  "ldh": {
    "type": "alias",
    "alias": "ldh / ldhio"
  },
  "ldhio": {
    "type": "alias",
    "alias": "ldh / ldhio"
  },
  "ldhu": {
    "type": "alias",
    "alias": "ldhu / ldhuio"
  },
  "ldhuio": {
    "type": "alias",
    "alias": "ldhu / ldhuio"
  },
  "ldw": {
    "type": "alias",
    "alias": "ldw / ldwio"
  },
  "ldwio": {
    "type": "alias",
    "alias": "ldw / ldwio"
  },
  "sth": {
    "type": "alias",
    "alias": "sth / sthio"
  },
  "sthio": {
    "type": "alias",
    "alias": "sth / sthio"
  },
  "stw": {
    "type": "alias",
    "alias": "stw / stwio"
  },
  "stwio": {
    "type": "alias",
    "alias": "stw / stwio"
  },
  "r0": {
    "type": "alias",
    "alias": "r0 / zero"
  },
  "zero": {
    "type": "alias",
    "alias": "r0 / zero"
  },
  "r1": {
    "type": "alias",
    "alias": "r1 / at"
  },
  "at": {
    "type": "alias",
    "alias": "r1 / at"
  },
  "r24": {
    "type": "alias",
    "alias": "r24 / et"
  },
  "et": {
    "type": "alias",
    "alias": "r24 / et"
  },
  "r25": {
    "type": "alias",
    "alias": "r25 / bt"
  },
  "bt": {
    "type": "alias",
    "alias": "r25 / bt"
  },
  "r26": {
    "type": "alias",
    "alias": "r26 / gb"
  },
  "gb": {
    "type": "alias",
    "alias": "r26 / gb"
  },
  "r27": {
    "type": "alias",
    "alias": "r27 / sp"
  },
  "sp": {
    "type": "alias",
    "alias": "r27 / sp"
  },
  "r28": {
    "type": "alias",
    "alias": "r28 / fp"
  },
  "fp": {
    "type": "alias",
    "alias": "r28 / fp"
  },
  "r29": {
    "type": "alias",
    "alias": "r29 / ea"
  },
  "ea": {
    "type": "alias",
    "alias": "r29 / ea"
  },
  "r30": {
    "type": "alias",
    "alias": "r30 / sstatus"
  },
  "sstatus": {
    "type": "alias",
    "alias": "r30 / sstatus"
  },
  "r31": {
    "type": "alias",
    "alias": "r31 / ra"
  },
  "ra": {
    "type": "alias",
    "alias": "r31 / ra"
  }
}
